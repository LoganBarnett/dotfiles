# This was generated by home-manager running with a flake installation.
{
  description = "Nix configuration of logan";

  nixConfig = {
    extra-substituters = [
      "https://nix-community.cachix.org"
    ];
    extra-trusted-public-keys = [
      # For torch, I think.
      "nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs="
      "cuda-maintainers.cachix.org-1:0dq3bujKpuEPMCX6U4WylrUDZ9JyUG0VpVZa7CNfq5E="
    ];
  };

  # See https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/inputs for
  # various URL notations.
  inputs = {
    agenix = {
      url = "github:ryantm/agenix";
      inputs.darwin.follows = "nix-darwin";
      inputs.home-manager.follows = "home-manager";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    # https://github.com/oddlama/agenix-rekey
    # Allows re-keying and bootstrapping of secrets used by agenix.
    agenix-rekey = {
      url = "github:LoganBarnett/agenix-rekey/parameterize-generators";
      # url = "github:LoganBarnett/agenix-rekey/paramterize-generators-cherry-pick";
      # url = "github:LoganBarnett/agenix-rekey/parameterize-generators";
      # url = "github:LoganBarnett/agenix-rekey/parameterize-generators-master-identities-fix";
      # url = "git+file:///Users/logan/dev/agenix-rekey?ref=parameterize-generators";
      # There is a documented gotcha in the readme if this must change.  Review
      # agenix-rekey's README for details.
      inputs.nixpkgs.follows = "nixpkgs";
    };
    # Attic is a Nix cache server.
    attic = {
      url = "github:zhaofengli/attic";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    authentik-nix = {
      url = "github:nix-community/authentik-nix";
    };
    dns-smart-block = {
      url = "path:/Users/logan/dev/dns-smart-block";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    # Give us a tool for getting the current system.  See
    # https://discourse.nixos.org/t/getting-the-current-system-from-the-command-line/19781/10
    # for discussion on the matter.
    current-system = {
      url = "github:nix-systems/current-system";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    disko = {
      url = "github:nix-community/disko";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    emacs-overlay = {
      url = "github:nix-community/emacs-overlay/master";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    github-to-jenkins-webhook = {
      # TODO: Always keep one path example around.  Don't use file:// unless
      # you're pointing at a tarball (which should happen just about never).
      url = "path:/Users/logan/dev/github-to-jenkins-webhook";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    # Allow Flatpak usage, specifically so we can install Roblox via Sober.
    flatpaks.url = "github:in-a-dil-emma/declarative-flatpak/latest";

    home-manager-working-rocm = {
      url = "github:nix-community/home-manager/release-24.11";
      inputs.nixpkgs.follows = "nixpkgs-working-rocm";
    };
    nextcloud-desktop = {
      # What's on master doesn't build with the current settings.  It looks like
      # they've moved onto qt6 but Nix has many components that don't work on
      # qt6 on darwin.  So pin it to the last known working state.
      url = "github:nextcloud/desktop?dir=admin/nix&rev=19a2f8cc7da52f62b6e7f4ca3b68ba7056b46f4e";
      # inputs.nixpkgs.follows = "nixpkgs";
    };
    nix-darwin = {
      url = "github:LnL7/nix-darwin/nix-darwin-25.11";
      # rev = "72dd60bfc98c128149d84213b17d1b8a68863055";
      # Leaving this present breaks things and nix-darwin will not load or
      # otherwise will not be present.  It is not understood why, even though
      # documentation typically recommends this step.
      inputs.nixpkgs.follows = "nixpkgs";
    };
    # Allow surgical edits to static/literal Nix files.  Great for doing things
    # like bumping a version and hash automatically.
    nix-editor = {
      url = "github:snowfallorg/nix-editor";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    nix-homebrew.url = "github:zhaofengli/nix-homebrew";
    nix-option-search = {
      url = "github:ciderale/nix-option-search";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    nixos-generators = {
      # url = "github:LoganBarnett/nixos-generators?ref=add-sd-image-raspberrypi";
      url = "github:nix-community/nixos-generators/master";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    nixos-anywhere = {
      url = "github:numtide/nixos-anywhere";
      inputs = {
        nixpkgs.follows = "nixpkgs";
        disko.follows = "disko";
      };
    };
    nixos-hardware = {
      url = "github:NixOS/nixos-hardware/master";
      # nixos-hardware doesn't actually use nixpkgs.
      # inputs.nixpkgs.follows = "nixpkgs";
    };
    # Give us the ability to manage the boot options via config.txt,
    # declaratively.
    nixos-raspberrypi = {
      url = "github:nvmd/nixos-raspberrypi/develop";
      inputs.nixpkgs.follows = "nixpkgs-nixos-raspberrypi";
    };
    nixpkgs-nixos-raspberrypi = {
      url = "github:nvmd/nixpkgs/modules-with-keys-25.11";
    };
    # This is forced at the moment, because we have some heavy deltas coming
    # into flake.lock and I want that to stabilize before I pin it here.
    # nixpkgs.url = "github:nixos/nixpkgs?ref=f9f59197478b3ec9c954b67ae0d1d5429de23124";
    nixpkgs.url = "github:nixos/nixpkgs/25.11";
    nixpkgs-working-rocm.url = "github:nixos/nixpkgs/master";
    nixpkgs-cuda.url = "github:nixos/nixpkgs/master";
    nixpkgs-25-11.url = "github:nixos/nixpkgs/25.11";
    nixpkgs-openscad-bin.url = github:LoganBarnett/nixpkgs/openscad-darwin-preserve-cli;
    # The newest version of Octoprint on nixpkgs 25.11 enters some kind of
    # refresh loop on the UI, and my attempts to debug it have come up empty.
    # It doesn't print any apparent error - I believe it is misidentifying
    # authentication issues.  This issue exists even when all of the
    # authentication settings are removed.
    # nixpkgs-octoprint.url = "github:nixos/nixpkgs/24.11";
    # We need a version of nixpkgs for things that want to constantly
    # auto-update themselves in a forceful (yet asinine) manner.  Culprits
    # include Signal Desktop, but I should add more to the shame list as I find
    # them.
    nixpkgs-latest.url = "github:nixos/nixpkgs/master";
    comfyui-pr.url = "github:LoganBarnett/nixpkgs?ref=comfyui-fetch-model-hide-rebase";
    nixos-option-pr-369151.url = "github:nixos/nixpkgs?ref=pull/369151/head";
    # This is the Nix runtime itself, so be real careful about bumping this.
    # But at least now I can bump it without having to reinstall everything.
    nix = {
      # Use this pull request to do `nix store break-lock <derv-path>` to remove
      # locks on errant builds.  I've seen this lodged on macOS once out a very
      # long time.  Might be related to remote builds.
      # https://github.com/NixOS/nix/pull/13813
      url = "github:siraben/nix?ref=store-break-lock";
      # url = "github:nixos/nix?ref=2.24.11";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    home-manager = {
      url = "github:nix-community/home-manager/release-25.11";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    openhab-flake = {
      url = "github:LoganBarnett/openhab-flake/add-darwin-devshell-support";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    programsdb = {
      url = "github:wamserma/flake-programs-sqlite";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    repo-sync-flake = {
      url = "github:LoganBarnett/repo-sync";
      inputs.nixpkgs.follows = "nixpkgs";
    };

    sytter = {
      # TODO: Always keep one path example around.  Don't use file:// unless
      # you're pointing at a tarball (which should happen just about never).
      url = "path:/Users/logan/dev/sytter";
      # url = github:LoganBarnett/sytter/add-nix-darwin-module-as-launchctl-service;
      inputs.nixpkgs.follows = "nixpkgs";
    };

    typeypipe-flake = {
      url = "github:dkoontz/TypeyPipe";
      # url = "github:LoganBarnett/TypeyPipe";
      # url = "path:/Users/logan/dev/TypeyPipe";
      # inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = flake-inputs@{
    agenix-rekey,
    nix,
    nix-darwin,
    nixpkgs,
    nixpkgs-latest,
    nixos-generators,
    self,
    ...
  }: let
    facts = import ./nixos-modules/facts.nix;
    nodes =
      self.containerGuestHosts
      // self.nixosConfigurations
      // self.darwinConfigurations
    ;
    container-guest-host = args@{ host-id, flake-inputs, system }: nix-host args;
      # autoStart = true;
      # privateNetwork = false;
      # # This is a critical gotcha with containers in NixOS.  Set `specialArgs`
      # # to be the typical flake-input-to-module stuff that you would set on a
      # # normal host (e.g. `nixosSystem`).  Without this, you blunder into
      # # unhelpful infinite recursion issues.  See
      # # https://discourse.nixos.org/t/infinite-recursion-caused-by-flake-input-in-a-container-in-nixops/39590/4
      # # for a detailed explanation.
      # specialArgs = {
      #   inherit facts flake-inputs host-id nodes system;
      #   host-id = "grafana";
      # };
      # config = import ./hosts/${host-id}.nix;
    # };

    nix-host = args@{ host-id, flake-inputs, system }:
      flake-inputs.nixpkgs.lib.nixosSystem {
        specialArgs = {
          inherit facts flake-inputs host-id nodes system;
          disko-proper = flake-inputs.disko;
          lib-custom = import ./lib.nix;
        };
        modules = [
          flake-inputs.home-manager.nixosModules.home-manager
          flake-inputs.nix-option-search.nixosModules.default
          ./hosts/${host-id}.nix
          # This is the only way to pull in this dependency.  In the flake it
          # resides in, this is already imported, so importing it again via
          # `imports` just makes Nix barf with an infinite recursion error.
          # openhab-flake.nixosModules.${system}.openhab
          {
            home-manager.extraSpecialArgs = {
              inherit facts flake-inputs host-id;
            };
          }
        ];
      }
    ;

    darwin-host = args@{ host-id, flake-inputs, system }:
      nix-darwin.lib.darwinSystem {
        specialArgs = {
          inherit facts flake-inputs host-id nodes system;
          lib-custom = import ./lib.nix;
          disko-proper = flake-inputs.disko;
        };
        modules = [
          flake-inputs.home-manager.darwinModules.home-manager
          # flake-inputs.nix-option-search.darwinModules.default
          {
            nixpkgs.overlays = [
              (final: prev: {
                nixos-option = flake-inputs
                  .nixos-option-pr-369151
                  .outputs
                  .legacyPackages
                  .${system}
                  .nixos-option
                ;
              })
            ];
          }
          {
            home-manager.extraSpecialArgs = {
              inherit facts flake-inputs host-id system;
            };
          }
          ./hosts/${host-id}.nix
        ];
      }
    ;

    lib = nixpkgs.lib;
    host-config = name: hostFacts: {
      flake-inputs = flake-inputs // (
        lib.attrsets.mapAttrs
          (name: input-name: flake-inputs."${input-name}")
          (hostFacts.flake-input-overrides or {})
      );
      host-id = name;
      system = hostFacts.system;
    };
    # Only give us converted hosts for given OS (platform?).  This way we can
    # pick which hosts go to which `*Configurations` attribute
    # (e.g. nixosConfigurations vs darwinConfigurations).
    host-configs-for-os = f: os: hostsFacts: lib.pipe hostsFacts [
      (lib.attrsets.filterAttrs (name: hostFacts:
        # Perhaps dangerous - we need a better way of parsing these things since
        # they are known to be inconsistent, and sometimes we're dealing with a
        # double while other times it might be a triple.
        hostFacts ? system
        && (
          builtins.elemAt (lib.strings.splitString "-" hostFacts.system) 1
        ) == os
      ))
      (lib.attrsets.mapAttrs host-config)
      (lib.attrsets.mapAttrs (n: f))
    ];
  in  {
    darwinConfigurations = host-configs-for-os darwin-host "darwin" facts.network.hosts;
    nixosConfigurations = host-configs-for-os nix-host "linux" facts.network.hosts;
    containerGuestHosts = {};
    # containerGuestHosts.grafana = container-guest-host {
    #   inherit flake-inputs;
    #   host-id = "grafana";
    #   system = "aarch64-linux";
    # };
    packages.aarch64-darwin.nucleus = self
      .nixosConfigurations
      .nucleus
      .config
      .system
      .build
      .isoImage
    ;

    packages.aarch64-darwin.nucleus-ng = let
      system = "x86_64-linux";
      host-id = "nucleus";
    in nixos-generators.nixosGenerate {
      inherit system;
      format = "install-iso";
      specialArgs = {
        inherit facts flake-inputs host-id nodes system;
        disko-proper = flake-inputs.disko;
      };
      modules = [
        ./hosts/nucleus.nix
      ];
    };
    # Just expose Disko in some ways - used by ../bin/remote-deploy.
    packages.x86_64-linux.disko = flake-inputs.disko.packages.x86_64-linux.disko or flake-inputs.disko.packages.x86_64-linux.default;
    packages.aarch64-linux.disko = flake-inputs.disko.packages.aarch64-linux.disko or flake-inputs.disko.packages.aarch64-linux.default;


    agenix-rekey = agenix-rekey.configure {
      userFlake = self;
      # nodes = self.nixosConfigurations
      #         // self.darwinConfigurations;
      nixosConfigurations =
        self.nixosConfigurations
          // self.darwinConfigurations
          // self.containerGuestHosts
      ;
      # This doesn't seem to actually make the overlays available to secret
      # generators.  I suspect a bug, but cannot yet prove it.
      pkgs = import flake-inputs.nixpkgs {
        system = "aarch64-darwin";
        overlays = import ./overlays/default.nix;
      };
    };

  };

}
